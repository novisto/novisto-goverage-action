// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package data

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getRecentCoverage = `-- name: GetRecentCoverage :one
SELECT id, repo_name, project_name, branch_name, commit, coverage, coverage_date, raw_data FROM coverage
WHERE repo_name = $1
    AND project_name = $2
    AND branch_name = $3
ORDER BY coverage_date DESC
LIMIT 1
`

type GetRecentCoverageParams struct {
	RepoName    string
	ProjectName string
	BranchName  string
}

func (q *Queries) GetRecentCoverage(ctx context.Context, arg GetRecentCoverageParams) (Coverage, error) {
	row := q.db.QueryRow(ctx, getRecentCoverage, arg.RepoName, arg.ProjectName, arg.BranchName)
	var i Coverage
	err := row.Scan(
		&i.ID,
		&i.RepoName,
		&i.ProjectName,
		&i.BranchName,
		&i.Commit,
		&i.Coverage,
		&i.CoverageDate,
		&i.RawData,
	)
	return i, err
}

const listCoverageAsc = `-- name: ListCoverageAsc :many
SELECT id, repo_name, project_name, branch_name, commit, coverage, coverage_date, raw_data FROM coverage
WHERE repo_name = $1
  AND project_name = $2
  AND branch_name = $3
ORDER BY coverage_date ASC
OFFSET $4
LIMIT $5
`

type ListCoverageAscParams struct {
	RepoName    string
	ProjectName string
	BranchName  string
	Offset      int32
	Limit       int32
}

func (q *Queries) ListCoverageAsc(ctx context.Context, arg ListCoverageAscParams) ([]Coverage, error) {
	rows, err := q.db.Query(ctx, listCoverageAsc,
		arg.RepoName,
		arg.ProjectName,
		arg.BranchName,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Coverage
	for rows.Next() {
		var i Coverage
		if err := rows.Scan(
			&i.ID,
			&i.RepoName,
			&i.ProjectName,
			&i.BranchName,
			&i.Commit,
			&i.Coverage,
			&i.CoverageDate,
			&i.RawData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCoverageDesc = `-- name: ListCoverageDesc :many
SELECT id, repo_name, project_name, branch_name, commit, coverage, coverage_date, raw_data FROM coverage
WHERE repo_name = $1
    AND project_name = $2
    AND branch_name = $3
ORDER BY coverage_date DESC
OFFSET $4
LIMIT $5
`

type ListCoverageDescParams struct {
	RepoName    string
	ProjectName string
	BranchName  string
	Offset      int32
	Limit       int32
}

func (q *Queries) ListCoverageDesc(ctx context.Context, arg ListCoverageDescParams) ([]Coverage, error) {
	rows, err := q.db.Query(ctx, listCoverageDesc,
		arg.RepoName,
		arg.ProjectName,
		arg.BranchName,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Coverage
	for rows.Next() {
		var i Coverage
		if err := rows.Scan(
			&i.ID,
			&i.RepoName,
			&i.ProjectName,
			&i.BranchName,
			&i.Commit,
			&i.Coverage,
			&i.CoverageDate,
			&i.RawData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertCoverage = `-- name: UpsertCoverage :one
INSERT INTO coverage (repo_name, project_name, branch_name, commit, coverage, coverage_date, raw_data)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (repo_name, project_name, branch_name, commit)
    DO UPDATE SET coverage = $5, coverage_date = $6, raw_data = $7
RETURNING id, repo_name, project_name, branch_name, commit, coverage, coverage_date, raw_data
`

type UpsertCoverageParams struct {
	RepoName     string
	ProjectName  string
	BranchName   string
	Commit       string
	Coverage     float64
	CoverageDate pgtype.Timestamptz
	RawData      []byte
}

func (q *Queries) UpsertCoverage(ctx context.Context, arg UpsertCoverageParams) (Coverage, error) {
	row := q.db.QueryRow(ctx, upsertCoverage,
		arg.RepoName,
		arg.ProjectName,
		arg.BranchName,
		arg.Commit,
		arg.Coverage,
		arg.CoverageDate,
		arg.RawData,
	)
	var i Coverage
	err := row.Scan(
		&i.ID,
		&i.RepoName,
		&i.ProjectName,
		&i.BranchName,
		&i.Commit,
		&i.Coverage,
		&i.CoverageDate,
		&i.RawData,
	)
	return i, err
}
